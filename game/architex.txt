Описание архитектуры

Игровое время разбито на ходы и импульсы.
Минимальной единицей действия в игре является процедура.
Процедуры хода перечислены в turnChart, процедуры импульса - в impChart.
Процедура импульса является частным случаем процедуры хода.
Переключение процедур выполняется switchProc.
В начале каждой процедуры всем объектам рассылается сообщение, в котором указано название процедуры.

У объектов могут быть обработчики событий, которые выполняют простейшие действия. Например,
оружие может отслеживать начало импульса, чтобы считать четверть хода после выстрела для подзарядки.

Но существуют более сложные действия, требующие ожидания решений игрока. Для этого используются акции.
Акциями управляют агенты. Каждый агент специализируется на своём действии. Имя агента совпадает с именем акции.
Агент создаёт акцию, которая JSON-является объектом. Обязательно есть имя акции, совпадающее с именем агента.
А так же uid объекта. И состояние, которое сначала Begin.
Кроме того, в акции обычно есть список вариантов действий.
Акции хранятся в ассоциативном массиве game.actions. Их берут контроллеры и отправляют на обработку.

Контроллеры отвечают за обработку акции. Акция, которая ушла на обработку принимает состояние Wait.
Контроллер может обладать логикой, достаточной чтобы выбрать нужные варианты действий.
Простейший контроллер управляет наведением ракет. Он обрабатывает акции Move и выбирает подходящее направление.
Есть контроллер, выполняющий связь с игроком. Он отправляет акцию на клиент.
Клиент реагирует на приход акции - выводит элементы интерфейса, позволяющие игроку сделать выбор.
Когда пользователь нажимает Next, акция с результатами выбора пересылается на сервер.
Там она поступает обратно в агент, где выполняются нужные действия. Акция удаляется.

Сценарий обработки процедуры
game.nextStep > TurnEvents.ImpulseProc > ImpEvents.MoveShips
В ImpEvents.MoveShips вызывается
		game.beginGlbActionIf(movAgent, (game, ship) => ship.isCanMove(game))
Из game.beginGlbActionIf
    const action = agent.createAction({game: this, ship})
movAgent.createAction
    Если ship.handlers.isCanChangeDir(params.game), то создать акцию
    Особенностью акции Move является наличие списка list с координатами трех гексов для возможного перемещения
    А так же поле current=0, т.к. первым в списке идет направление вперёд.
В game.beginGlbActionIf
    полученная акция попадает в this.actions.set(ship.uid, action)
Затем из game.nextStep вызывается sendActions()
    там if (action.state === ActionState.Begin)
            action.state = ActionState.Wait
            ctrl.onAction(this, action)
Контроллер в onAction отправляет акцию на клиент
Клиент использует список list для вывода трёх подсвеченных гексов, которые может выбрать пользователь.
При клике на один из гексов, он становится ярче, а его индекс сохраняется в поле current
При нажатии Next происходит отправка акции на сервер.
Сервер при поступлении акции от клиента вызывает game.onActionIncome(action)
    там происходит поиск аналогичной акции среди game.actions по uid
    Поступившая акция мержится в существующую. Так что теоретически, можно прислать только name, uid и current
    А если где-то хранится ссылка на экземпляр акции, то она остаётся действующей, а данные обновляются.
    Акция переходит в состояние End
    Вызывается game.receiveActions()
game.receiveActions()
    Проверяется весь список game.actions.
    Если есть хотя бы одна акция не в состоянии End, значит нужно ещё ждать ответа от контроллера
    Если все End, то для каждой акции вызывается execAction(game, action), после чего акция удаляется из списка
execAction > movAgent.execAction
    Корабль перемещается в гекс, указанный полем action.current